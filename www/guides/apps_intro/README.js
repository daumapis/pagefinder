Ext.data.JsonP.apps_intro({"guide":"<h1 id='apps_intro-section-intro-to-applications-with-sencha-touch'>Intro to Applications with Sencha Touch</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/apps_intro-section-anatomy-of-an-app'>Anatomy of an App</a></li>\n<li><a href='#!/guide/apps_intro-section-controllers'>Controllers</a></li>\n<li><a href='#!/guide/apps_intro-section-stores'>Stores</a></li>\n<li><a href='#!/guide/apps_intro-section-device-profiles'>Device Profiles</a></li>\n<li><a href='#!/guide/apps_intro-section-launch-process'>Launch Process</a></li>\n<li><a href='#!/guide/apps_intro-section-routing-and-history-support'>Routing and History Support</a></li>\n<li><a href='#!/guide/apps_intro-section-further-reading'>Further Reading</a></li>\n</ol>\n</div>\n\n<p>Sencha Touch is optimized for building apps that work across multiple platforms. To\nmake writing apps as simple as possible, we provide a simple but powerful\napp architecture that leverages the Model View Controller (MVC) pattern. This\napproach keeps your code clean, testable, and easy to maintain, and provides you with a\nnumber of benefits when it comes to writing your apps:</p>\n\n<ul>\n<li><strong>History Support</strong>: Enables you to navigate within your apps using back button support,\nand access any part of your app that can be linked to</li>\n<li><strong>Deep Linking</strong>: Enables you to share deep links that open any screen in your app,\njust like linking to a web page</li>\n<li><strong>Device Profiles</strong>: Enables you to easily customize your app's UI for phones, tablets,\nand other devices, while sharing common code</li>\n</ul>\n\n\n<h2 id='apps_intro-section-anatomy-of-an-app'>Anatomy of an App</h2>\n\n<p>An app is a collection of Models, Views, Controllers, Stores, and Profiles,\nplus additional metadata for app-related entities, such as application icons and\nlaunch screen images.</p>\n\n<p><strong>Note</strong> In this guide, Application indicates an instance of\n<a href=\"http://docs.sencha.com/touch/2-2/#!/api/Ext.app.Application\">Ext.application</a>,\nwhereas application or app is the program you're coding.</p>\n\n<p><p class='screenshot'><img src='guides/apps_intro/architecture-overview.png' alt=''><span></span></p></p>\n\n<ul>\n<li><strong>Models</strong>: represent a type of data object in your app - for example an e-commerce\napp might have models for User, Product, and Order</li>\n<li><strong>Views</strong>: are responsible for displaying data to your users and for leveraging the\nbuilt-in components in Sencha Touch</li>\n<li><strong>Controllers</strong>: handle interaction with your application, by listening for\nuser interactions, such as taps and swipes, and taking action accordingly</li>\n<li><strong>Stores</strong>: are responsible for loading data into your app and for powering\ncomponents such as Lists and DataViews</li>\n<li><strong>Profiles</strong>: enable you to easily customize your app's UI for tablets and phones,\nwhile sharing as much code as possible</li>\n</ul>\n\n\n<p>Application is usually the first entity you define in a Sencha Touch\napp, for example:</p>\n\n<pre><code><a href=\"#!/api/Ext-method-application\" rel=\"Ext-method-application\" class=\"docClass\">Ext.application</a>({\n    name: 'MyApp',\n    models: ['User', 'Product', 'nested.Order'],\n    views: ['OrderList', 'OrderDetail', 'Main'],\n    controllers: ['Orders'],\n\n    launch: function() {\n        <a href=\"#!/api/Ext-method-create\" rel=\"Ext-method-create\" class=\"docClass\">Ext.create</a>('MyApp.view.Main');\n    }\n});\n</code></pre>\n\n<p>The <em><a href=\"#!/api/Ext.app.Application-cfg-name\" rel=\"Ext.app.Application-cfg-name\" class=\"docClass\">name</a></em> is used to create a single global namespace for\nyour entire app, including all of its models, views, controllers, and other classes.\nFor example, an app called <em>MyApp</em> should have its constituent classes follow the\npattern <em>MyApp.model.User</em>, <em>MyApp.controller.Users</em>, <em>MyApp.view.Main</em>, and so on.\nThis keeps the entire app under a single global variable, thus minimizing the chance\nof other code on the same page conflicting with it.</p>\n\n<p>The app uses the defined <em><a href=\"#!/api/Ext.app.Application-cfg-models\" rel=\"Ext.app.Application-cfg-models\" class=\"docClass\">models</a></em>,\n<em><a href=\"#!/api/Ext.app.Application-cfg-views\" rel=\"Ext.app.Application-cfg-views\" class=\"docClass\">views</a></em>\nand <em><a href=\"#!/api/Ext.app.Application-cfg-controllers\" rel=\"Ext.app.Application-cfg-controllers\" class=\"docClass\">controllers</a></em> configurations to automatically\nload these classes into your app. The classes follow a simple file structure\nconvention - models are expected to be in the app/model directory, controllers in the\napp/controller directory and views inside the app/view directory - for\nexample <em>app/model/User.js</em>, <em>app/controllers/Orders.js</em> and <em>app/view/Main.js</em>.</p>\n\n<p>Note that one of the <a href=\"#!/api/Ext.app.Application-cfg-models\" rel=\"Ext.app.Application-cfg-models\" class=\"docClass\">models</a> we previously specified\nis different than the others, in the sense that we specified its\nfull class name (\"MyApp.model.nested.Order\"). We are able to specify the full class name\nfor any of these configurations, if we do not follow the normal naming conventions.\nSee the <a href=\"#!/api/Ext.app.Application\" rel=\"Ext.app.Application\" class=\"docClass\">Dependencies</a> section of the <a href=\"#!/api/Ext.app.Application\" rel=\"Ext.app.Application\" class=\"docClass\">Ext.app.Application</a> docs\nfor details on how to specify custom dependencies.</p>\n\n<h2 id='apps_intro-section-controllers'>Controllers</h2>\n\n<p>Controllers are the glue that bind an app together. Controllers listen for events\nfired by the UI and take an action based on the event. Using Controllers helps\nkeep your code clean and readable, and separates the view logic from the control logic.</p>\n\n<p>For example, let's assume you require users to log in to your app via a login form.\nThe view in this case is the form with all its fields and other controls.\nA controller should listen to the <a href=\"#!/api/Ext.Button-event-tap\" rel=\"Ext.Button-event-tap\" class=\"docClass\">tap</a> event on the form's\nsubmit <a href=\"#!/api/Ext.Button\" rel=\"Ext.Button\" class=\"docClass\">button</a> and perform the authentication itself.\nAnytime we deal with manipulating data or state, the controller should\nbe the class that activates that change, not a view.</p>\n\n<p>Controllers expose a small but powerful set of features, and follow a few simple\nconventions. Each Controller in your app is a subclass of\n<a href=\"#!/api/Ext.app.Controller\" rel=\"Ext.app.Controller\" class=\"docClass\">Ext.app.Controller</a> - although you can subclass existing Controllers,\nas long as they inherit from <a href=\"#!/api/Ext.app.Controller\" rel=\"Ext.app.Controller\" class=\"docClass\">Ext.app.Controller</a> at some point. Controllers\nexist in the MyApp.controller.* namespace. For example, if your app has a\nSessions controller, it would be called MyApp.controller.Sessions and would\nexist in the file, app/controller/Sessions.js.</p>\n\n<p>Although each Controller is a subclass of <a href=\"#!/api/Ext.app.Controller\" rel=\"Ext.app.Controller\" class=\"docClass\">Ext.app.Controller</a>, each one is\ninstantiated only once by the <a href=\"#!/api/Ext.app.Application\" rel=\"Ext.app.Application\" class=\"docClass\">Application</a> that\nloaded it. At any time, there is only one instance of each Controller and\nthe set of Controller instances are managed internally by the Application.\nUsing an app's <a href=\"#!/api/Ext.app.Application-cfg-controllers\" rel=\"Ext.app.Application-cfg-controllers\" class=\"docClass\">controllers</a>\nconfig (as previously shown) loads all of the Controllers and instantiates\nthem automatically.</p>\n\n<h3 id='apps_intro-section-a-simple-example'>A Simple Example</h3>\n\n<p>Here is how we might quickly define the Sessions controller we described\npreviously. We are using two Controller configurations:</p>\n\n<ul>\n<li><a href=\"#!/api/Ext.app.Controller-cfg-refs\" rel=\"Ext.app.Controller-cfg-refs\" class=\"docClass\">refs</a></li>\n<li><a href=\"#!/api/Ext.app.Controller-cfg-control\" rel=\"Ext.app.Controller-cfg-control\" class=\"docClass\">control</a></li>\n</ul>\n\n\n<p>Refs are an easy way to\nfind Components on your page - in this case the Controller looks for\nall Components that match the <a href=\"#!/api/Ext.form.Panel\" rel=\"Ext.form.Panel\" class=\"docClass\">formpanel</a> xtype\nand assigns the first one found to the <em>loginForm</em> property.\nWe subsequently use that property in the doLogin function.</p>\n\n<p>The second configuration is <a href=\"#!/api/Ext.app.Controller-cfg-control\" rel=\"Ext.app.Controller-cfg-control\" class=\"docClass\">control</a>.\nSimilar to the ref's\nconfig, this uses a <a href=\"#!/api/Ext.ComponentQuery\" rel=\"Ext.ComponentQuery\" class=\"docClass\">ComponentQuery</a> selector\nto find all <em>formpanel</em> xtypes that contain a <em>button</em>\n(for example, this finds the Submit button in our hypothetical login form).\nWhenever a button of this type fires its <a href=\"#!/api/Ext.Button-event-tap\" rel=\"Ext.Button-event-tap\" class=\"docClass\">tap</a> event,\nour Controller's <code>doLogin</code> function is called:</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('MyApp.controller.Sessions', {\n    extend: '<a href=\"#!/api/Ext.app.Controller\" rel=\"Ext.app.Controller\" class=\"docClass\">Ext.app.Controller</a>',\n\n    config: {\n        refs: {\n            loginForm: 'formpanel'\n        },\n        control: {\n            'formpanel button': {\n                tap: 'doLogin'\n            }\n        }\n    },\n\n    doLogin: function() {\n        var form   = this.getLoginForm(),\n            values = form.getValues();\n\n        MyApp.authenticate(values);\n    }\n});\n</code></pre>\n\n<p>The doLogin function itself is straightforward. Because we defined\na <code>loginForm</code> ref, the Controller automatically generates\na <code>getLoginForm</code> function that returns the <em>formpanel</em> that it matches.\nOnce we have that form reference, we pull out its values\n(username and password) and pass them to an <em>authenticate</em> function.\nThat is mostly what a Controller does - listens for events that fire\n(usually by the UI) and initiate some action, in this case authenticating.</p>\n\n<p>For more information on Controllers and their capabilities see\nthe <a href=\"#!/guide/controllers\">controllers guide</a>.</p>\n\n<h2 id='apps_intro-section-stores'>Stores</h2>\n\n<p>Stores are an important part of Sencha Touch and power most of the\ndata-bound widgets. At its simplest, a Store is not much more than\nan array of Model instances. Data-bound Components such\nas <a href=\"#!/api/Ext.dataview.List\" rel=\"Ext.dataview.List\" class=\"docClass\">List</a> and <a href=\"#!/api/Ext.dataview.DataView\" rel=\"Ext.dataview.DataView\" class=\"docClass\">DataView</a><br/>\nrender one item for each Model instance contained in the Store.\nAs Model instances are added or removed from the Store, events fire,\nwhich the data-bound Components listen to and use to update themselves.</p>\n\n<p>See the <a href=\"#!/guide/stores\">Stores guide</a> for more information on\nStores, how they fit with Components in your app, and specific\nintegration points with your\n<a href=\"#!/api/Ext.app.Application\" rel=\"Ext.app.Application\" class=\"docClass\">Application</a> instance that you should be aware of.</p>\n\n<h2 id='apps_intro-section-device-profiles'>Device Profiles</h2>\n\n<p>Sencha Touch operates across a wide range of devices with differing\ncapabilities and screen sizes. A user interface that works well on a\ntablet may not work very well on a phone and vice versa, so it makes\nsense to provide customized views for different device types. However,\nwe do not want to have to write our app multiple times just to provide\na different UI, but we would like to share as much code as possible.</p>\n\n<p>Device Profiles are simple classes that enable you to define the\ndifferent types of devices supported by your app and how they should\nbe handled differently. They are optional, meaning you can develop\nyour app without profiles at first and add them in later, or never use\nthem at all. Each profile simply defines an\n<a href=\"#!/api/Ext.app.Profile-method-isActive\" rel=\"Ext.app.Profile-method-isActive\" class=\"docClass\">isActive</a> function that should\nreturn true if that profile should be active on the current device,\nplus a set of additional <em><a href=\"#!/api/Ext.app.Profile-cfg-models\" rel=\"Ext.app.Profile-cfg-models\" class=\"docClass\">models</a></em>,\n<em><a href=\"#!/api/Ext.app.Profile-cfg-views\" rel=\"Ext.app.Profile-cfg-views\" class=\"docClass\">views</a></em>, and\n<em><a href=\"#!/api/Ext.app.Profile-cfg-controllers\" rel=\"Ext.app.Profile-cfg-controllers\" class=\"docClass\">controllers</a></em> that load if\nthat profile is detected.</p>\n\n<p>To add Profile support to your app, you need to tell your Application about\nthe Profiles and create <a href=\"#!/api/Ext.app.Profile\" rel=\"Ext.app.Profile\" class=\"docClass\">Ext.app.Profile</a> subclasses for each,\nfor example:</p>\n\n<pre><code><a href=\"#!/api/Ext-method-application\" rel=\"Ext-method-application\" class=\"docClass\">Ext.application</a>({\n    name: 'MyApp',\n    profiles: ['Phone', 'Tablet']\n\n    // as before\n});\n</code></pre>\n\n<p>By defining the Phone and Tablet profiles, the Application loads\nthe app/profile/Phone.js and app/profile/Tablet.js files. Let's assume\nthat the tablet version of the app supports additional capabilities,\nfor example managing groups. This example shows how you can define\na Tablet profile:</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('MyApp.profile.Tablet', {\n    extend: '<a href=\"#!/api/Ext.app.Profile\" rel=\"Ext.app.Profile\" class=\"docClass\">Ext.app.Profile</a>',\n\n    config: {\n        controllers: ['Groups'],\n        views: ['GroupAdmin'],\n        models: ['MyApp.model.Group']\n    },\n\n    isActive: function() {\n        return Ext.os.is.Tablet;\n    }\n});\n</code></pre>\n\n<p>The isActive function returns true whenever the app runs on what Sencha Touch\ndetermines to be a tablet. This is a slightly subjective determination because\nthere is a near-continuous spectrum of device shapes and sizes with no clear\ndistinction between phones and tablets. Because there is no secure way to state\nwhich devices are tablets and which are phones, Sencha Touch's <em>Ext.os.is.Tablet</em>\nis set to true when running on an iPad and false otherwise. If you need more\nfine-grained control, it is easy to provide any implementation you like inside\nyour <em>isActive</em> function, as long as it returns true or false.</p>\n\n<p>You should ensure that only one of your Profiles returns true from\nits <code>isActive</code> function. If more than one profile returns true, only the\nfirst one is used and the rest are ignored. The first profile that returns true\nsets the Application's <a href=\"#!/api/Ext.app.Application-cfg-currentProfile\" rel=\"Ext.app.Application-cfg-currentProfile\" class=\"docClass\">currentProfile</a>,\nwhich you can query at any time.</p>\n\n<p>If the detected currentProfile defines additional models, views, controllers,\nand stores, these are automatically loaded by the Application, along with all\nof the <em><a href=\"#!/api/Ext.app.Application-cfg-models\" rel=\"Ext.app.Application-cfg-models\" class=\"docClass\">models</a></em>,\n<em><a href=\"#!/api/Ext.app.Application-cfg-views\" rel=\"Ext.app.Application-cfg-views\" class=\"docClass\">views</a></em> and\n<em><a href=\"#!/api/Ext.app.Application-cfg-controllers\" rel=\"Ext.app.Application-cfg-controllers\" class=\"docClass\">controllers</a></em> defined on the Application\nitself. However, all of the dependencies named in the Profile are prepended with\nthe Profile name, unless the fully-qualified class name is provided. For example:</p>\n\n<ul>\n<li><em>views: ['GroupAdmin']</em> loads <em>app/view/tablet/GroupAdmin.js</em></li>\n<li><em>controllers: ['Groups']</em> loads <em>app/controller/tablet/Groups.js</em></li>\n<li><em>models: ['MyApp.model.Group']</em> loads <em>app/model/Group.js</em></li>\n</ul>\n\n\n<p>Most of the time, a Profile only defines additional controllers and views, as the\nmodels and stores are typically shared between all variants of the app. For a more\ndetailed discussion of Profiles see the <a href=\"#!/guide/profiles\">device profiles guide</a>.</p>\n\n<h2 id='apps_intro-section-launch-process'>Launch Process</h2>\n\n<p>Each Application can define a <a href=\"#!/api/Ext.app.Application-cfg-launch\" rel=\"Ext.app.Application-cfg-launch\" class=\"docClass\">launch</a> function,\nwhich is called as soon as all of your app's classes have been loaded and the app\nis ready to launch. This is usually the best place to place any app startup logic,\ntypically creating the main view structure for your app.</p>\n\n<p>In addition to the Application launch function, there are two other places where\nyou can place app startup logic. First, each Controller is able to define an\n<a href=\"#!/api/Ext.app.Controller-cfg-init\" rel=\"Ext.app.Controller-cfg-init\" class=\"docClass\">init</a> function, which is called before the\nApplication launch function. Second, if you are using Device Profiles, each\nProfile can define a <a href=\"#!/api/Ext.app.Profile-method-launch\" rel=\"Ext.app.Profile-method-launch\" class=\"docClass\">launch</a> function, which is\ncalled after the Controller init functions, but before the Application launch function.</p>\n\n<p><strong>Note</strong> Only the active Profile has its launch function called - for example if you\ndefine profiles for Phone and Tablet and then launch the app on a tablet, only the\nTablet Profile's launch function is called.</p>\n\n<p>The launch order is:</p>\n\n<ol>\n<li>Controller#init functions called</li>\n<li>Profile#launch function called</li>\n<li>Application#launch function called</li>\n<li>Controller#launch functions called</li>\n</ol>\n\n\n<p>When using Profiles, it is common to place most of the bootup logic inside the\nProfile launch function, because each Profile has a different set of views that\nneed to be constructed at startup.</p>\n\n<h2 id='apps_intro-section-routing-and-history-support'>Routing and History Support</h2>\n\n<p>Sencha Touch has full Routing and History support. Several of the SDK examples,\nincluding the Kitchen Sink application, use history support to enable the\nback button for easily navigating between screens. This is especially useful\non Android devices.</p>\n\n<!-- Dispatch/redirect\nRouter\nRestoring State -->\n\n\n<h2 id='apps_intro-section-further-reading'>Further Reading</h2>\n\n<p>The following guides provide additional information on using the Sencha Touch\napplication architecture:</p>\n\n<ul>\n<li><a href=\"#!/guide/controllers\">Controllers</a></li>\n<li><a href=\"#!/guide/profiles\">Device Profiles</a></li>\n</ul>\n\n\n<!-- * [History Support](#!/guide/history_support) -->\n\n\n<!-- * [Views](#!/guide/views) -->\n\n\n<!-- * [Testing Applications](#!/guide/testing_mvc) -->\n\n","title":"All about Applications"});